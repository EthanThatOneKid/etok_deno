use super::quoted_split::{is_space_byte, quoted_split};

static GENERATE_COMMENT: &str = "//deno:generate";

/// ParsedComment is a command that is generated by a //deno:generate
/// comment in a source file.
#[derive(Debug, PartialEq)]
pub struct ParsedComment {
  args: Vec<String>,
  original: String,
  alias: Option<String>,
  line: usize,
  character: usize,
}

impl ParsedComment {
  pub fn args(&self) -> &[String] {
    &self.args
  }

  pub fn original(&self) -> &str {
    &self.original
  }

  pub fn alias(&self) -> Option<&str> {
    self.alias.as_deref()
  }

  pub fn line(&self) -> usize {
    self.line
  }

  pub fn character(&self) -> usize {
    self.character
  }

  pub fn command(&self) -> &str {
    self.args[0].as_str()
  }

  pub fn command_args(&self) -> &[String] {
    &self.args[1..]
  }

  pub fn command_args_str(&self) -> Vec<&str> {
    self.args[1..].iter().map(|s| s.as_str()).collect()
  }
}

pub trait CharLocation {
  fn line(&self) -> usize;
  fn character(&self) -> usize;
}

impl CharLocation for ParsedComment {
  fn line(&self) -> usize {
    self.line
  }

  fn character(&self) -> usize {
    self.character
  }
}

pub fn parse_comments(content: &str) -> Vec<ParsedComment> {
  let mut cmds = vec![];
  let mut pos = 0;
  let mut last_char: char = '\0';

  while let Some(i) = content[pos..].find(GENERATE_COMMENT) {
    let start = pos + i + GENERATE_COMMENT.len(); // skip "//deno:generate"
    let mut end = start;

    while let Some(j) = content[end..].find("\n") {
      end += j + 1;
      if last_char == '\\' {
        let backslash_end = end - 2;
        if content[backslash_end..].starts_with("\r\n") {
          end += 1;
        }
        if is_space_byte(&content[end..end + 1]) {
          end += 1;
        }
        last_char = '\0';
      } else {
        break;
      }
    }

    let comment = &content[start..end - 1];
    let comment_pos = pos + i;
    let matches = quoted_split(comment);
    let mut args = Vec::new();
    let mut alias: Option<String> = None;

    if !matches.is_empty() {
      if matches[0] == "-command" {
        if matches.len() >= 3 {
          alias = Some(matches[1].clone().to_string());
          args = matches[2..].to_vec();
        }
      } else {
        args = matches;
      }
    }

    let cmd = ParsedComment {
      args,
      original: &comment.to_string(),
      alias,
      line: content[..comment_pos].lines().count(),
      character: comment_pos - content[..comment_pos].rfind('\n').unwrap_or(0),
    };

    cmds.push(cmd);
    pos = end;
    last_char = content[end - 2..end - 1].chars().next().unwrap_or('\0');
  }

  cmds
}

#[cfg(test)]
mod tests {
  use super::*;

  #[test]
  fn test_parse_comments() {
    let input = "\
            //deno:generate echo \"Hello World!\"\n\
            //deno:generate -command my_command echo \\\n\
            //  \"Hello World!\"\n\
            //deno:generate echo \\\n\
            //  \"Hello World!\"\n\
            //deno:generate echo \"Hello \\\n\
            //World!\"";
    let expected = vec![
      ParsedComment {
        args: vec!["echo".to_string(), "Hello World!".to_string()],
        line: 0,
        character: 0,
        original: "//deno:generate echo \"Hello World!\"".to_string(),
        alias: None,
      },
      ParsedComment {
        args: vec!["echo".to_string(), "Hello World!".to_string()],
        line: 1,
        character: 0,
        original: "echo \"Hello World!\"".to_string(),
        alias: Some("my_command".to_string()),
      },
      ParsedComment {
        args: vec!["echo".to_string(), "Hello World!".to_string()],
        line: 1,
        character: 0,
        original: "//deno:generate echo \\\n//  \"Hello World!\"".to_string(),
        alias: None,
      },
      ParsedComment {
        args: vec![
          "echo".to_string(),
          "Hello".to_string(),
          "World!".to_string(),
        ],
        line: 2,
        character: 0,
        original: "//deno:generate echo \"Hello \\\n//World!\"".to_string(),
        alias: None,
      },
    ];

    assert_eq!(expected, parse_comments(input));
  }

  #[test]
  fn test_parse_comments_with_windows_line_endings() {
    let input = "\
            //deno:generate echo \"Hello World!\"\r\n\
            //deno:generate -command my_command echo \\\r\n\
            //  \"Hello World!\"\r\n\
            //deno:generate echo \\\r\n\
            //  \"Hello World!\"\r\n\
            //deno:generate echo \"Hello \\\r\n\
            //World!\"";
    let expected = vec![
      ParsedComment {
        args: vec!["echo".to_string(), "Hello World!".to_string()],
        line: 0,
        character: 0,
        original: "//deno:generate echo \"Hello World!\"".to_string(),
        alias: None,
      },
      ParsedComment {
        args: vec!["echo".to_string(), "Hello World!".to_string()],
        line: 1,
        character: 0,
        original: "echo \"Hello World!\"".to_string(),
        alias: Some("my_command".to_string()),
      },
      ParsedComment {
        args: vec!["echo".to_string(), "Hello World!".to_string()],
        line: 1,
        character: 0,
        original: "//deno:generate echo \\\r" + "//  \"Hello World!\"",
        alias: None,
      },
      ParsedComment {
        args: vec![
          "echo".to_string(),
          "Hello".to_string(),
          "World!".to_string(),
        ],
        line: 2,
        character: 0,
        original: "//deno:generate echo \"Hello \\\r" + "//World!\"",
        alias: None,
      },
    ];
  }
}
